// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

$(function() {
  return $("#console").submit(function() {
    var code, source;
    source = $("#console textarea").val();
    code = CoffeeScript.compile(source);
    eval(code);
    return false;
  });
});

(function($) {
  var defaults;
  $.event.fix = (function(originalFix) {
    return function(event) {
      event = originalFix.apply(this, arguments);
      if (event.type.indexOf('drag') === 0 || event.type.indexOf('drop') === 0) {
        event.dataTransfer = event.originalEvent.dataTransfer;
      }
      return event;
    };
  })($.event.fix);
  defaults = {
    callback: $.noop,
    matchType: /image.*/
  };
  return $.fn.dropImageReader = function(options) {
    var stopFn;
    if (typeof options === "function") {
      options = {
        callback: options
      };
    }
    options = $.extend({}, defaults, options);
    stopFn = function(event) {
      event.stopPropagation();
      return event.preventDefault();
    };
    return this.each(function() {
      var $this, element;
      element = this;
      $this = $(this);
      $this.bind('dragenter dragover dragleave', stopFn);
      return $this.bind('drop', function(event) {
        stopFn(event);
        return Array.prototype.forEach.call(event.dataTransfer.files, function(file) {
          var reader;
          if (!file.type.match(options.matchType)) {
            return;
          }
          reader = new FileReader();
          reader.onload = function(evt) {
            return options.callback.call(element, {
              dataURL: evt.target.result,
              event: evt,
              file: file,
              name: file.name
            });
          };
          return reader.readAsDataURL(file);
        });
      });
    });
  };
})(jQuery);

window.Map = function(drawAt) {
  var cameraAngle, cameraRotation, canvas, cellsLong, cellsTall, cellsWide, drawCell, drawObject, height, layerData, layers, loadLayers, parseLayer, render, setData, tileAt, tileHeight, tileWidth, tiles, topLayer, width;
  if (drawAt == null) {
    drawAt = function() {};
  }
  tileWidth = 64;
  tileHeight = 32;
  width = 640;
  height = 480;
  cellsWide = 8;
  cellsLong = 8;
  cellsTall = 8;
  cameraAngle = 0..turns;
  cameraRotation = Matrix.rotation(cameraAngle, Point(3.5, 3.5));
  topLayer = 1;
  canvas = $("<canvas width=" + width + " height=" + height + " id='map'>").appendTo("body").pixieCanvas();
  parseLayer = function(text) {
    return text.split("\n").map(function(row) {
      return row.split('').map(function(n) {
        var res;
        res = parseInt(n, 36);
        if (res !== 0) {
          return res || void 0;
        } else {
          return res;
        }
      });
    });
  };
  render = function() {
    canvas.clear();
    cellsTall.times(function(k) {
      if (k >= topLayer) {
        canvas.globalAlpha(0.25);
      } else {
        canvas.globalAlpha(1);
      }
      return cellsWide.times(function(i) {
        return cellsLong.times(function(j) {
          var p, tile;
          j = (cellsLong - 1) - j;
          p = cameraRotation.transformPoint(Point(i, j)).round();
          tile = tileAt(p.x, p.y, k);
          if (tile) {
            drawCell(tile, i, j, k);
          }
          return drawAt(p.x, p.y, k, tile);
        });
      });
    });
    return this;
  };
  layerData = [];
  layers = [];
  tiles = [];
  if (Filetree.sha("tilemap")) {
    Filetree.load("tilemap", function(data) {
      if (data) {
        return loadLayers(data);
      }
    });
  } else {
    CAS.getJSON("a296b41fb709d9d0e0433754546400e5f003f17a", function(data) {
      return loadLayers(data);
    });
  }
  tileAt = function(i, j, k) {
    var _ref, _ref1;
    return tiles[(_ref = layers[k]) != null ? (_ref1 = _ref[i]) != null ? _ref1[j] : void 0 : void 0];
  };
  setData = function(i, j, k, id) {
    var _base;
    return ((_base = (layers[k] || (layers[k] = [])))[i] || (_base[i] = []))[j] = id;
  };
  drawObject = function(object, x, y) {
    return object.draw(canvas, x, y + height / 2, cameraRotation);
  };
  loadLayers = function(data) {
    layerData = data;
    layers = layerData.map(parseLayer);
    $("#layers textarea").each(function(i) {
      return $(this).val(layerData[i]);
    });
    return render();
  };
  drawCell = function(object, i, j, k) {
    var x, y, z;
    x = (j * tileWidth / 2) + (i * tileWidth / 2);
    y = (i * tileHeight / 2) - (j * tileHeight / 2);
    z = k * tileHeight;
    return drawObject(object, x, y - z);
  };
  return {
    drawCell: drawCell,
    setData: setData,
    changeCameraAngle: function(delta) {
      cameraAngle += delta;
      cameraRotation = Matrix.rotation(cameraAngle, Point(3.5, 3.5));
      return this.render();
    },
    changeTopLayer: function(delta) {
      topLayer = (topLayer + delta).clamp(0, 7);
      return this.render();
    },
    setTopLayer: function(n) {
      topLayer = n.clamp(0, 7);
      return this.render();
    },
    adjacentTiles: function(i, j, k) {
      return [this.tileAt(i, j, k - 1), this.tileAt(i, j, k + 1), this.tileAt(i, j - 1, k), this.tileAt(i, j + 1, k), this.tileAt(i - 1, j, k), this.tileAt(i + 1, j, k)].compact();
    },
    tiles: function(newTiles) {
      tiles = newTiles;
      return render();
    },
    loadLayers: loadLayers,
    saveLayerData: function() {
      var sha;
      sha = CAS.storeJSON(layerData);
      return Filetree.set("tilemap", sha);
    },
    isClear: function(i, j, k) {
      var tile;
      tile = tileAt(i, j, k);
      return !tile || (tile.solid === false);
    },
    tileAt: tileAt,
    "eval": function(code) {
      return eval(code);
    },
    render: render
  };
};

(function($) {
  return $.fn.pixieCanvas = function(options) {
    var $canvas, canvas, canvasAttrAccessor, context, contextAttrAccessor;
    if (options == null) {
      options = {};
    }
    canvas = this.get(0);
    context = void 0;
    /**
    PixieCanvas provides a convenient wrapper for working with Context2d.
    
    Methods try to be as flexible as possible as to what arguments they take.
    
    Non-getter methods return `this` for method chaining.
    
    @name PixieCanvas
    @constructor
    */

    $canvas = $(canvas).extend({
      /**
      Passes this canvas to the block with the given matrix transformation
      applied. All drawing methods called within the block will draw
      into the canvas with the transformation applied. The transformation
      is removed at the end of the block, even if the block throws an error.
      
      @name withTransform
      @methodOf PixieCanvas#
      
      @param {Matrix} matrix
      @param {Function} block
      
      @returns {PixieCanvas} this
      */

      withTransform: function(matrix, block) {
        context.save();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        try {
          block(this);
        } finally {
          context.restore();
        }
        return this;
      },
      /**
      Clear the canvas (or a portion of it).
      
      Clear the entire canvas
      
      <code><pre>
      canvas.clear()
      </pre></code>
      
      Clear a portion of the canvas
      
      <code class="run"><pre>
      # Set up: Fill canvas with blue
      canvas.fill("blue")
      
      # Clear a portion of the canvas
      canvas.clear
        x: 50
        y: 50
        width: 50
        height: 50
      </pre></code>
      
      You can also clear the canvas by passing x, y, width height as
      unnamed parameters:
      
      <code><pre>
      canvas.clear(25, 25, 50, 50)
      </pre></code>
      
      @name clear
      @methodOf PixieCanvas#
      
      @param {Number} [x] where to start clearing on the x axis
      @param {Number} [y] where to start clearing on the y axis
      @param {Number} [width] width of area to clear
      @param {Number} [height] height of area to clear
      
      @returns {PixieCanvas} this
      */

      clear: function(x, y, width, height) {
        var _ref;
        if (x == null) {
          x = {};
        }
        if (y == null) {
          _ref = x, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height;
        }
        x || (x = 0);
        y || (y = 0);
        if (width == null) {
          width = canvas.width;
        }
        if (height == null) {
          height = canvas.height;
        }
        context.clearRect(x, y, width, height);
        return this;
      },
      /**
      Fills the entire canvas (or a specified section of it) with
      the given color.
      
      <code class="run"><pre>
      # Paint the town (entire canvas) red
      canvas.fill "red"
      
      # Fill a section of the canvas white (#FFF)
      canvas.fill
        x: 50
        y: 50
        width: 50
        height: 50
        color: "#FFF"
      </pre></code>
      
      @name fill
      @methodOf PixieCanvas#
      
      @param {Number} [x=0] Optional x position to fill from
      @param {Number} [y=0] Optional y position to fill from
      @param {Number} [width=canvas.width] Optional width of area to fill
      @param {Number} [height=canvas.height] Optional height of area to fill
      @param {Bounds} [bounds] bounds object to fill
      @param {String|Color} [color] color of area to fill
      
      @returns {PixieCanvas} this
      */

      fill: function(color) {
        var bounds, height, width, x, y, _ref;
        if (color == null) {
          color = {};
        }
        if (!((typeof color.isString === "function" ? color.isString() : void 0) || color.channels)) {
          _ref = color, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height, bounds = _ref.bounds, color = _ref.color;
        }
        if (bounds) {
          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;
        }
        x || (x = 0);
        y || (y = 0);
        if (width == null) {
          width = canvas.width;
        }
        if (height == null) {
          height = canvas.height;
        }
        this.fillColor(color);
        context.fillRect(x, y, width, height);
        return this;
      },
      /**
      A direct map to the Context2d draw image. `GameObject`s
      that implement drawable will have this wrapped up nicely,
      so there is a good chance that you will not have to deal with
      it directly.
      
      @name drawImage
      @methodOf PixieCanvas#
      
      @param image
      @param {Number} sx
      @param {Number} sy
      @param {Number} sWidth
      @param {Number} sHeight
      @param {Number} dx
      @param {Number} dy
      @param {Number} dWidth
      @param {Number} dHeight
      
      @returns {PixieCanvas} this
      */

      drawImage: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        context.drawImage.apply(context, args);
        return this;
      },
      /**
      Draws a circle at the specified position with the specified
      radius and color.
      
      <code class="run"><pre>
      # Draw a large orange circle
      canvas.drawCircle
        radius: 30
        position: Point(100, 75)
        color: "orange"
      
      # Draw a blue circle with radius 10 at (25, 50)
      # and a red stroke
      canvas.drawCircle
        x: 25
        y: 50
        radius: 10
        color: "blue"
        stroke:
          color: "red"
          width: 1
      
      # Create a circle object to set up the next examples
      circle =
        radius: 20
        x: 50
        y: 50
      
      # Draw a given circle in yellow
      canvas.drawCircle
        circle: circle
        color: "yellow"
      
      # Draw the circle in green at a different position
      canvas.drawCircle
        circle: circle
        position: Point(25, 75)
        color: "green"
      
      # Draw an outline circle in purple.
      canvas.drawCircle
        x: 50
        y: 75
        radius: 10
        stroke:
          color: "purple"
          width: 2
      </pre></code>
      
      @name drawCircle
      @methodOf PixieCanvas#
      
      @param {Number} [x] location on the x axis to start drawing
      @param {Number} [y] location on the y axis to start drawing
      @param {Point} [position] position object of location to start drawing. This will override x and y values passed
      @param {Number} [radius] length of the radius of the circle
      @param {Color|String} [color] color of the circle
      @param {Circle} [circle] circle object that contains position and radius. Overrides x, y, and radius if passed
      @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width
      
      @returns {PixieCanvas} this
      */

      drawCircle: function(_arg) {
        var circle, color, position, radius, stroke, x, y;
        x = _arg.x, y = _arg.y, radius = _arg.radius, position = _arg.position, color = _arg.color, stroke = _arg.stroke, circle = _arg.circle;
        if (circle) {
          x = circle.x, y = circle.y, radius = circle.radius;
        }
        if (position) {
          x = position.x, y = position.y;
        }
        radius = radius.clamp(0, Infinity);
        context.beginPath();
        context.arc(x, y, radius, 0, Math.TAU, true);
        context.closePath();
        if (color) {
          this.fillColor(color);
          context.fill();
        }
        if (stroke) {
          this.strokeColor(stroke.color);
          this.lineWidth(stroke.width);
          context.stroke();
        }
        return this;
      },
      /**
      Draws a rectangle at the specified position with given
      width and height. Optionally takes a position, bounds
      and color argument.
      
      <code class="run"><pre>
      # Draw a red rectangle using x, y, width and height
      canvas.drawRect
        x: 50
        y: 50
        width: 50
        height: 50
        color: "#F00"
      
      # Draw a blue rectangle using position, width and height
      # and throw in a stroke for good measure
      canvas.drawRect
        position: Point(0, 0)
        width: 50
        height: 50
        color: "blue"
        stroke:
          color: "orange"
          width: 3
      
      # Set up a bounds object for the next examples
      bounds =
        x: 100
        y: 0
        width: 100
        height: 100
      
      # Draw a purple rectangle using bounds
      canvas.drawRect
        bounds: bounds
        color: "green"
      
      # Draw the outline of the same bounds, but at a different position
      canvas.drawRect
        bounds: bounds
        position: Point(0, 50)
        stroke:
          color: "purple"
          width: 2
      </pre></code>
      
      @name drawRect
      @methodOf PixieCanvas#
      
      @param {Number} [x] location on the x axis to start drawing
      @param {Number} [y] location on the y axis to start drawing
      @param {Number} [width] width of rectangle to draw
      @param {Number} [height] height of rectangle to draw
      @param {Point} [position] position to start drawing. Overrides x and y if passed
      @param {Color|String} [color] color of rectangle
      @param {Bounds} [bounds] bounds of rectangle. Overrides x, y, width, height if passed
      @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width
      
      @returns {PixieCanvas} this
      */

      drawRect: function(_arg) {
        var bounds, color, height, position, stroke, width, x, y;
        x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;
        if (bounds) {
          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;
        }
        if (position) {
          x = position.x, y = position.y;
        }
        if (color) {
          this.fillColor(color);
          context.fillRect(x, y, width, height);
        }
        if (stroke) {
          this.strokeColor(stroke.color);
          this.lineWidth(stroke.width);
          context.strokeRect(x, y, width, height);
        }
        return this;
      },
      /**
      Draw a line from `start` to `end`.
      
      <code class="run"><pre>
      # Draw a sweet diagonal
      canvas.drawLine
        start: Point(0, 0)
        end: Point(200, 200)
        color: "purple"
      
      # Draw another sweet diagonal
      canvas.drawLine
        start: Point(200, 0)
        end: Point(0, 200)
        color: "red"
        width: 6
      
      # Now draw a sweet horizontal with a direction and a length
      canvas.drawLine
        start: Point(0, 100)
        length: 200
        direction: Point(1, 0)
        color: "orange"
      
      </pre></code>
      
      @name drawLine
      @methodOf PixieCanvas#
      
      @param {Point} start position to start drawing from
      @param {Point} [end] position to stop drawing
      @param {Number} [width] width of the line
      @param {String|Color} [color] color of the line
      
      @returns {PixieCanvas} this
      */

      drawLine: function(_arg) {
        var color, direction, end, length, start, width;
        start = _arg.start, end = _arg.end, width = _arg.width, color = _arg.color, direction = _arg.direction, length = _arg.length;
        width || (width = 3);
        if (direction) {
          end = direction.norm(length).add(start);
        }
        this.lineWidth(width);
        this.strokeColor(color);
        context.beginPath();
        context.moveTo(start.x, start.y);
        context.lineTo(end.x, end.y);
        context.closePath();
        context.stroke();
        return this;
      },
      /**
      Draw a polygon.
      
      <code class="run"><pre>
      # Draw a sweet rhombus
      canvas.drawPoly
        points: [
          Point(50, 25)
          Point(75, 50)
          Point(50, 75)
          Point(25, 50)
        ]
        color: "purple"
        stroke:
          color: "red"
          width: 2
      </pre></code>
      
      @name drawPoly
      @methodOf PixieCanvas#
      
      @param {Point[]} [points] collection of points that define the vertices of the polygon
      @param {String|Color} [color] color of the polygon
      @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width
      
      @returns {PixieCanvas} this
      */

      drawPoly: function(_arg) {
        var color, points, stroke;
        points = _arg.points, color = _arg.color, stroke = _arg.stroke;
        context.beginPath();
        points.each(function(point, i) {
          if (i === 0) {
            return context.moveTo(point.x, point.y);
          } else {
            return context.lineTo(point.x, point.y);
          }
        });
        context.lineTo(points[0].x, points[0].y);
        if (color) {
          this.fillColor(color);
          context.fill();
        }
        if (stroke) {
          this.strokeColor(stroke.color);
          this.lineWidth(stroke.width);
          context.stroke();
        }
        return this;
      },
      /**
      Draw a rounded rectangle.
      
      Adapted from http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html
      
      <code class="run"><pre>
      # Draw a purple rounded rectangle with a red outline
      canvas.drawRoundRect
        position: Point(25, 25)
        radius: 10
        width: 150
        height: 100
        color: "purple"
        stroke:
          color: "red"
          width: 2
      </pre></code>
      
      @name drawRoundRect
      @methodOf PixieCanvas#
      
      @param {Number} [x] location on the x axis to start drawing
      @param {Number} [y] location on the y axis to start drawing
      @param {Number} [width] width of the rounded rectangle
      @param {Number} [height] height of the rounded rectangle
      @param {Number} [radius=5] radius to round the rectangle corners
      @param {Point} [position] position to start drawing. Overrides x and y if passed
      @param {Color|String} [color] color of the rounded rectangle
      @param {Bounds} [bounds] bounds of the rounded rectangle. Overrides x, y, width, and height if passed
      @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width
      
      @returns {PixieCanvas} this
      */

      drawRoundRect: function(_arg) {
        var bounds, color, height, position, radius, stroke, width, x, y;
        x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, radius = _arg.radius, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;
        if (radius == null) {
          radius = 5;
        }
        if (bounds) {
          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;
        }
        if (position) {
          x = position.x, y = position.y;
        }
        context.beginPath();
        context.moveTo(x + radius, y);
        context.lineTo(x + width - radius, y);
        context.quadraticCurveTo(x + width, y, x + width, y + radius);
        context.lineTo(x + width, y + height - radius);
        context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        context.lineTo(x + radius, y + height);
        context.quadraticCurveTo(x, y + height, x, y + height - radius);
        context.lineTo(x, y + radius);
        context.quadraticCurveTo(x, y, x + radius, y);
        context.closePath();
        if (color) {
          this.fillColor(color);
          context.fill();
        }
        if (stroke) {
          this.lineWidth(stroke.width);
          this.strokeColor(stroke.color);
          context.stroke();
        }
        return this;
      },
      /**
      Draws text on the canvas at the given position, in the given color.
      If no color is given then the previous fill color is used.
      
      <code class="run"><pre>
      # Fill canvas to indicate bounds
      canvas.fill
        color: '#eee'
      
      # A line to indicate the baseline
      canvas.drawLine
        start: Point(25, 50)
        end: Point(125, 50)
        color: "#333"
        width: 1
      
      # Draw some text, note the position of the baseline
      canvas.drawText
        position: Point(25, 50)
        color: "red"
        text: "It's dangerous to go alone"
      
      </pre></code>
      
      @name drawText
      @methodOf PixieCanvas#
      
      @param {Number} [x] location on x axis to start printing
      @param {Number} [y] location on y axis to start printing
      @param {String} text text to print
      @param {Point} [position] position to start printing. Overrides x and y if passed
      @param {String|Color} [color] color of text to start printing
      @param {String} [font] font of text to print
      
      @returns {PixieCanvas} this
      */

      drawText: function(_arg) {
        var color, font, position, text, x, y;
        x = _arg.x, y = _arg.y, text = _arg.text, position = _arg.position, color = _arg.color, font = _arg.font;
        if (position) {
          x = position.x, y = position.y;
        }
        this.fillColor(color);
        if (font) {
          this.font(font);
        }
        context.fillText(text, x, y);
        return this;
      },
      /**
      Centers the given text on the canvas at the given y position. An x position
      or point position can also be given in which case the text is centered at the
      x, y or position value specified.
      
      <code class="run"><pre>
      # Fill canvas to indicate bounds
      canvas.fill
        color: "#eee"
      
      # A line to indicate the baseline
      canvas.drawLine
        start: Point(25, 25)
        end: Point(125, 25)
        color: "#333"
        width: 1
      
      # Center text on the screen at y value 25
      canvas.centerText
        y: 25
        color: "red"
        text: "It's dangerous to go alone"
      
      # Center text at point (75, 75)
      canvas.centerText
        position: Point(75, 75)
        color: "green"
        text: "take this"
      
      </pre></code>
      
      @name centerText
      @methodOf PixieCanvas#
      
      @param {String} text Text to print
      @param {Number} [y] location on the y axis to start printing
      @param {Number} [x] location on the x axis to start printing. Overrides the default centering behavior if passed
      @param {Point} [position] position to start printing. Overrides x and y if passed
      @param {String|Color} [color] color of text to print
      @param {String} [font] font of text to print
      
      @returns {PixieCanvas} this
      */

      centerText: function(_arg) {
        var color, font, position, text, textWidth, x, y;
        text = _arg.text, x = _arg.x, y = _arg.y, position = _arg.position, color = _arg.color, font = _arg.font;
        if (position) {
          x = position.x, y = position.y;
        }
        if (x == null) {
          x = canvas.width / 2;
        }
        textWidth = this.measureText(text);
        return this.drawText({
          text: text,
          color: color,
          font: font,
          x: x - textWidth / 2,
          y: y
        });
      },
      /**
      A getter / setter method to set the canvas fillColor.
      
      <code><pre>
      # Set the fill color
      canvas.fillColor('#FF0000')
      
      # Passing no arguments returns the fillColor
      canvas.fillColor()
      # => '#FF0000'
      
      # You can also pass a Color object
      canvas.fillColor(Color('sky blue'))
      </pre></code>
      
      @name fillColor
      @methodOf PixieCanvas#
      
      @param {String|Color} [color] color to make the canvas fillColor
      
      @returns {PixieCanvas} this
      */

      fillColor: function(color) {
        if (color) {
          if (color.channels) {
            context.fillStyle = color.toString();
          } else {
            context.fillStyle = color;
          }
          return this;
        } else {
          return context.fillStyle;
        }
      },
      /**
      A getter / setter method to set the canvas strokeColor.
      
      <code><pre>
      # Set the stroke color
      canvas.strokeColor('#FF0000')
      
      # Passing no arguments returns the strokeColor
      canvas.strokeColor()
      # => '#FF0000'
      
      # You can also pass a Color object
      canvas.strokeColor(Color('sky blue'))
      </pre></code>
      
      @name strokeColor
      @methodOf PixieCanvas#
      
      @param {String|Color} [color] color to make the canvas strokeColor
      
      @returns {PixieCanvas} this
      */

      strokeColor: function(color) {
        if (color) {
          if (color.channels) {
            context.strokeStyle = color.toString();
          } else {
            context.strokeStyle = color;
          }
          return this;
        } else {
          return context.strokeStyle;
        }
      },
      /**
      Determine how wide some text is.
      
      <code><pre>
      canvas.measureText('Hello World!')
      # => 55
      </pre></code>
      
      @name measureText
      @methodOf PixieCanvas#
      
      @param {String} [text] the text to measure
      
      @returns {PixieCanvas} this
      */

      measureText: function(text) {
        return context.measureText(text).width;
      },
      putImageData: function(imageData, x, y) {
        context.putImageData(imageData, x, y);
        return this;
      },
      context: function() {
        return context;
      },
      element: function() {
        return canvas;
      },
      createPattern: function(image, repitition) {
        return context.createPattern(image, repitition);
      },
      clip: function(x, y, width, height) {
        context.beginPath();
        context.rect(x, y, width, height);
        context.clip();
        return this;
      }
    });
    contextAttrAccessor = function() {
      var attrs;
      attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return attrs.each(function(attr) {
        return $canvas[attr] = function(newVal) {
          if (newVal != null) {
            context[attr] = newVal;
            return this;
          } else {
            return context[attr];
          }
        };
      });
    };
    canvasAttrAccessor = function() {
      var attrs;
      attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return attrs.each(function(attr) {
        return $canvas[attr] = function(newVal) {
          if (newVal != null) {
            canvas[attr] = newVal;
            return this;
          } else {
            return canvas[attr];
          }
        };
      });
    };
    contextAttrAccessor("font", "globalAlpha", "globalCompositeOperation", "lineWidth", "textAlign");
    canvasAttrAccessor("height", "width");
    if (canvas != null ? canvas.getContext : void 0) {
      context = canvas.getContext('2d');
      if (options.init) {
        options.init($canvas);
      }
      return $canvas;
    }
  };
})(jQuery);

window.PlayerCharacter = function(I) {
  if (I == null) {
    I = {};
  }
  return Object.extend({}, {
    __proto__: PlayerCharacter.prototype,
    health: 10,
    healthMax: 10
  }, I);
};

PlayerCharacter.prototype = {
  draw: function(canvas, x, y) {
    return canvas.drawImage(this.image, x + 16, y + 32 - this.yOffset);
  },
  renderOverlay: function() {
    return HAML.player_overlay(this);
  },
  move: function(delta) {
    var newPosition, onTile, tile;
    onTile = map.tileAt.apply(map, this.position);
    if (onTile && onTile.stairs) {
      delta.z += 1;
    }
    newPosition = pointClamp(pointAdd(this.position, delta), 0, 7);
    if (map.isClear.apply(map, newPosition)) {
      this.position = newPosition;
    }
    if (tile = map.tileAt.apply(map, this.position)) {
      return this.yOffset = tile.yOffset;
    } else {
      return this.yOffset = 0;
    }
  },
  special: function() {},
  cleanup: function() {},
  fall: function() {
    var onTile;
    onTile = map.tileAt.apply(map, this.position);
    if (onTile && onTile.surface) {

    } else {
      this.move([0, 0, -1]);
      this.move([0, 0, -1]);
      this.move([0, 0, -1]);
      this.move([0, 0, -1]);
    }
    if (this.position.z < 0) {
      return this.position.z = 0;
    }
  }
};

window.Tile = function(I) {
  var back, backImg, img, self, sha;
  if (I == null) {
    I = {};
  }
  sha = I.sha, back = I.back;
  img = $("<img>", {
    src: Resource.url(sha),
    load: function() {
      return self.height = this.height;
    }
  }).get(0);
  if (back) {
    backImg = $("<img>", {
      src: Resource.url(back),
      load: function() {
        return self.backHeight = this.height;
      }
    }).get(0);
  }
  return self = Object.extend({}, {
    __proto__: Tile.prototype,
    img: img,
    backImg: backImg,
    orientation: [1, 0]
  }, I);
};

Tile.prototype = {
  toJSON: function() {
    return _.omit(this, "img", "backImg");
  },
  draw: function(canvas, x, y, cameraRotation) {
    var back, hflip, img, imgHeight, imgWidth, offset, orientation, transform,
      _this = this;
    if (cameraRotation == null) {
      cameraRotation = Matrix.IDENTITY;
    }
    imgHeight = imgWidth = 64;
    orientation = cameraRotation.deltaTransformPoint(this.orientation).round();
    hflip = orientation.y;
    back = (orientation.x + orientation.y) < 0;
    if (back && this.backImg) {
      hflip = !hflip;
      img = this.backImg;
      offset = 64 - (this.backHeight || this.height);
    } else {
      img = this.img;
      offset = 64 - this.height;
    }
    if (hflip) {
      transform = Matrix.HORIZONTAL_FLIP;
    } else {
      transform = Matrix.IDENTITY;
    }
    return canvas.withTransform(Matrix.translation(x + imgWidth / 2, y + imgHeight / 2 + offset), function() {
      return canvas.withTransform(transform, function() {
        return canvas.drawImage(img, -imgWidth / 2, -imgHeight / 2);
      });
    });
  }
};

/*
TODO: Have front and back SHA so we can rotate the world
  front: SHA
  back: SHA
  orientation: [1, 0]
*/


window.Tileset = function(loaded) {
  var complete, loadSha, render, tiles;
  tiles = [];
  complete = function(data) {
    tiles = data.map(function(sha) {
      if (_.isString(sha)) {
        return Tile({
          sha: sha
        });
      } else {
        return Tile(sha);
      }
    });
    return loaded();
  };
  loadSha = function(sha) {
    return CAS.getJSON(sha, complete);
  };
  if (Filetree.sha("tileset")) {
    Filetree.load("tileset", complete);
  } else {
    loadSha("fb5eadfdbba50cddf5a8e1cedcfbc9184f0b0fd0");
  }
  render = function() {
    var $tiles;
    $tiles = $("#tiles").empty();
    return tiles.each(function(tile) {
      return $tiles.append(tile.img);
    });
  };
  return {
    render: render,
    loadSha: loadSha,
    tiles: function() {
      return tiles;
    },
    save: function(name) {
      if (name == null) {
        name = "tileset";
      }
      return Filetree.save(name, tiles);
    },
    get: function(n) {
      return tiles[n];
    },
    lookup: function(sha) {
      return tiles.select(function(tile) {
        return tile.sha === sha;
      }).first();
    },
    "eval": function(code) {
      return eval(code);
    }
  };
};

window.TileProtos = {
  stairs: {
    offset: 32,
    stair: true
  }
};

Object.extend(Storage, {
  pushData: function(name, value) {
    var list;
    list = this.list(name);
    if (!list.include(value)) {
      list.push(value);
    }
    this.store(name, list);
    return list;
  },
  removeData: function(name, value) {
    var list;
    list = this.list(name);
    list.remove(value);
    this.store(name, list);
    return list;
  },
  store: function(key, value) {
    localStorage[key] = JSON.stringify(value);
    return value;
  },
  list: function(name) {
    var existing;
    if (existing = localStorage[name]) {
      return JSON.parse(existing);
    } else {
      return [];
    }
  },
  hash: function(name) {
    var existing;
    if (existing = localStorage[name]) {
      return JSON.parse(existing);
    } else {
      return {};
    }
  },
  filetree: function() {
    return this.hash("filetree");
  },
  mergeTree: function(tree) {
    var key, mergedTree;
    key = "filetree";
    mergedTree = Object.extend(this.hash(key), tree);
    return this.store(key, mergedTree);
  }
});

window.Filetree = {
  set: function(name, sha) {
    var tree;
    tree = Storage.filetree();
    tree[name] = sha;
    return Storage.store("filetree", tree);
  },
  sha: function(name) {
    return Storage.filetree()[name];
  },
  save: function(name, data) {
    var sha;
    sha = CAS.storeJSON(data);
    return this.set(name, sha);
  },
  load: function(name, callback) {
    var sha;
    if (sha = Storage.filetree()[name]) {
      return CAS.getJSON(sha, callback);
    } else {
      return setTimeout(callback);
    }
  }
};

window.CAS = {
  storeJSON: function(data, type) {
    var jsonData;
    if (type == null) {
      type = "application/json";
    }
    jsonData = JSON.stringify(data);
    $.post('/upload', {
      data: jsonData,
      type: type
    });
    return CryptoJS.SHA1(jsonData).toString();
  },
  storeBase64: function(data, options) {
    var raw;
    if (options == null) {
      options = {};
    }
    Object.reverseMerge(options, {
      type: "image/png",
      callback: function() {}
    });
    $.post('/upload', {
      data_base64: data,
      type: options.type
    }, function() {
      return options.callback();
    });
    raw = CryptoJS.enc.Base64.parse(data);
    return CryptoJS.SHA1(raw).toString();
  },
  getJSON: function(sha, callback) {
    var url;
    url = Resource.url(sha, true);
    return $.getJSON(url, callback);
  }
};

window.Util = {
  dataFromDataURL: function(dataURL) {
    return dataURL.substr(dataURL.indexOf(',') + 1);
  },
  toCSON: function(obj) {
    var representation;
    representation = JSON.parse(JSON.stringify(obj));
    return Object.keys(representation).map(function(key) {
      var value;
      value = representation[key];
      return "" + key + ": " + (JSON.stringify(value));
    }).join("\n");
  }
};

window.Resource = {
  url: function(sha, crossOrigin) {
    var n, url;
    if (crossOrigin == null) {
      crossOrigin = false;
    }
    n = Math.floor(parseInt(sha.substring(0, 1), 16) / 4);
    url = "http://a" + n + ".pixiecdn.com/" + sha;
    if (crossOrigin) {
      return "" + url + "?" + location.host;
    } else {
      return url;
    }
  },
  imageFor: function(sha) {
    return $("<img>", {
      src: this.url(sha)
    }).get(0);
  }
};

window.UI = {
  buttons: function(buttons, selector) {
    if (selector == null) {
      selector = "body";
    }
    return _.each(buttons, function(fn, name) {
      return $("<button>", {
        text: name,
        click: fn
      }).appendTo(selector);
    });
  },
  actions: function(actions) {
    return _.each(actions, function(fn, key) {
      return $(document).bind("keydown", key, function() {
        fn();
        return false;
      });
    });
  }
};

window.Effect = {
  flash: function() {
    return $("canvas").css("opacity", 0).animate({
      opacity: 1
    }, "fast");
  }
};

["x", "y", "z"].each(function(dim, i) {
  return Object.defineProperty(Array.prototype, dim, {
    get: function() {
      return this[i];
    },
    set: function(x) {
      return this[i] = x;
    }
  });
});

Point.prototype.round = function() {
  return Point(this.x.round(), this.y.round());
};
