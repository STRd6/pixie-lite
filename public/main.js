// Generated by CoffeeScript 1.4.0

$(function() {
  return $("#console").submit(function() {
    var code, source;
    source = $("#console textarea").val();
    code = CoffeeScript.compile(source);
    eval(code);
    return false;
  });
});

(function($) {
  var defaults;
  $.event.fix = (function(originalFix) {
    return function(event) {
      event = originalFix.apply(this, arguments);
      if (event.type.indexOf('drag') === 0 || event.type.indexOf('drop') === 0) {
        event.dataTransfer = event.originalEvent.dataTransfer;
      }
      return event;
    };
  })($.event.fix);
  defaults = {
    callback: $.noop,
    matchType: /image.*/
  };
  return $.fn.dropImageReader = function(options) {
    var stopFn;
    if (typeof options === "function") {
      options = {
        callback: options
      };
    }
    options = $.extend({}, defaults, options);
    stopFn = function(event) {
      event.stopPropagation();
      return event.preventDefault();
    };
    return this.each(function() {
      var $this, element;
      element = this;
      $this = $(this);
      $this.bind('dragenter dragover dragleave', stopFn);
      return $this.bind('drop', function(event) {
        stopFn(event);
        return Array.prototype.forEach.call(event.dataTransfer.files, function(file) {
          var reader;
          if (!file.type.match(options.matchType)) {
            return;
          }
          reader = new FileReader();
          reader.onload = function(evt) {
            return options.callback.call(element, {
              dataURL: evt.target.result,
              event: evt,
              file: file,
              name: file.name
            });
          };
          return reader.readAsDataURL(file);
        });
      });
    });
  };
})(jQuery);

window.Map = function(drawAt) {
  var canvas, canvasElement, cellsLong, cellsTall, cellsWide, context, drawCell, drawObject, height, layerData, layers, loadLayers, parseLayer, render, tileAt, tileHeight, tileWidth, tiles, width;
  if (drawAt == null) {
    drawAt = function() {};
  }
  tileWidth = 64;
  tileHeight = 32;
  width = 640;
  height = 480;
  cellsWide = 8;
  cellsLong = 8;
  cellsTall = 8;
  canvas = $("<canvas width=" + width + " height=" + height + " id='map'>").appendTo("body");
  canvasElement = canvas.get(0);
  context = canvasElement.getContext("2d");
  parseLayer = function(text) {
    return text.split("\n").map(function(row) {
      return row.split('').map(function(n) {
        var res;
        res = parseInt(n, 36);
        if (res !== 0) {
          return res || void 0;
        } else {
          return res;
        }
      });
    });
  };
  render = function() {
    context.clearRect(0, 0, width, height);
    cellsTall.times(function(k) {
      return cellsWide.times(function(i) {
        return cellsLong.times(function(j) {
          var tile;
          j = (cellsLong - 1) - j;
          tile = tileAt(i, j, k);
          if (tile) {
            drawCell(tile, i, j, k);
          }
          return drawAt(i, j, k, tile);
        });
      });
    });
    return this;
  };
  layerData = [];
  layers = [];
  tiles = [];
  Filetree.load("tilemap", function(data) {
    if (data) {
      return loadLayers(data);
    }
  });
  tileAt = function(i, j, k) {
    var _ref, _ref1;
    return tiles[(_ref = layers[k]) != null ? (_ref1 = _ref[i]) != null ? _ref1[j] : void 0 : void 0];
  };
  drawObject = function(object, x, y) {
    return object.draw(context, x, y + height / 2);
  };
  loadLayers = function(data) {
    layerData = data;
    layers = layerData.map(parseLayer);
    $("#layers textarea").each(function(i) {
      return $(this).val(layerData[i]);
    });
    return render();
  };
  drawCell = function(object, i, j, k) {
    var x, y, z;
    x = (j * tileWidth / 2) + (i * tileWidth / 2);
    y = (i * tileHeight / 2) - (j * tileHeight / 2);
    z = k * tileHeight;
    return drawObject(object, x, y - z);
  };
  return {
    drawCell: drawCell,
    tiles: function(newTiles) {
      tiles = newTiles;
      return render();
    },
    loadLayers: loadLayers,
    saveLayerData: function() {
      var sha;
      sha = CAS.storeJSON(layerData);
      return Filetree.set("tilemap", sha);
    },
    isClear: function(i, j, k) {
      var tile;
      tile = tileAt(i, j, k);
      return !tile || (tile.solid === false);
    },
    tileAt: tileAt,
    "eval": function(code) {
      return eval(code);
    },
    render: render
  };
};

window.Tile = function(I) {
  var img, self, sha, url;
  if (I == null) {
    I = {};
  }
  sha = I.sha;
  url = Resource.url(sha);
  img = $("<img>", {
    src: url,
    load: function() {
      return self.height = this.height;
    }
  }).get(0);
  return self = Object.extend({}, {
    __proto__: Tile.prototype,
    img: img
  }, I);
};

Tile.prototype = {
  toJSON: function() {
    return _.omit(this, "img");
  },
  draw: function(canvas, x, y) {
    var offset;
    offset = 64 - this.height;
    return canvas.drawImage(this.img, x, y + offset);
  }
};

window.Tileset = function(loaded) {
  var complete, render, sha, tiles;
  tiles = [];
  complete = function(data) {
    tiles = data.map(function(sha) {
      if (_.isString(sha)) {
        return Tile({
          sha: sha
        });
      } else {
        return Tile(sha);
      }
    });
    return loaded();
  };
  if (Filetree.sha("tileset")) {
    Filetree.load("tileset", complete);
  } else {
    sha = "fb5eadfdbba50cddf5a8e1cedcfbc9184f0b0fd0";
    CAS.getJSON(sha, complete);
  }
  render = function() {
    var $tiles;
    $tiles = $("#tiles").empty();
    return tiles.each(function(tile) {
      return $tiles.append(tile.img);
    });
  };
  return {
    render: render,
    tiles: function() {
      return tiles;
    },
    save: function(name) {
      if (name == null) {
        name = "tileset";
      }
      return Filetree.save(name, tiles);
    },
    lookup: function(sha) {
      return tiles.select(function(tile) {
        return tile.sha === sha;
      }).first();
    },
    "eval": function(code) {
      return eval(code);
    }
  };
};

window.TileProtos = {
  stairs: {
    offset: 32,
    stair: true
  }
};

Object.extend(Storage, {
  pushData: function(name, value) {
    var list;
    list = this.list(name);
    if (!list.include(value)) {
      list.push(value);
    }
    this.store(name, list);
    return list;
  },
  removeData: function(name, value) {
    var list;
    list = this.list(name);
    list.remove(value);
    this.store(name, list);
    return list;
  },
  store: function(key, value) {
    localStorage[key] = JSON.stringify(value);
    return value;
  },
  list: function(name) {
    var existing;
    if (existing = localStorage[name]) {
      return JSON.parse(existing);
    } else {
      return [];
    }
  },
  hash: function(name) {
    var existing;
    if (existing = localStorage[name]) {
      return JSON.parse(existing);
    } else {
      return {};
    }
  },
  filetree: function() {
    return this.hash("filetree");
  },
  mergeTree: function(tree) {
    var key, mergedTree;
    key = "filetree";
    mergedTree = Object.extend(this.hash(key), tree);
    return this.store(key, mergedTree);
  }
});

window.Filetree = {
  set: function(name, sha) {
    var tree;
    tree = Storage.filetree();
    tree[name] = sha;
    return Storage.store("filetree", tree);
  },
  sha: function(name) {
    return Storage.filetree()[name];
  },
  save: function(name, data) {
    var sha;
    sha = CAS.storeJSON(data);
    return this.set(name, sha);
  },
  load: function(name, callback) {
    var sha;
    if (sha = Storage.filetree()[name]) {
      return CAS.getJSON(sha, callback);
    } else {
      return setTimeout(callback);
    }
  }
};

window.CAS = {
  storeJSON: function(data, type) {
    var jsonData;
    if (type == null) {
      type = "application/json";
    }
    jsonData = JSON.stringify(data);
    $.post('/upload', {
      data: jsonData,
      type: type
    });
    return CryptoJS.SHA1(jsonData).toString();
  },
  storeBase64: function(data, options) {
    var raw;
    if (options == null) {
      options = {};
    }
    Object.reverseMerge(options, {
      type: "image/png",
      callback: function() {}
    });
    $.post('/upload', {
      data_base64: data,
      type: options.type
    }, function() {
      return options.callback();
    });
    raw = CryptoJS.enc.Base64.parse(data);
    return CryptoJS.SHA1(raw).toString();
  },
  getJSON: function(sha, callback) {
    var url;
    url = Resource.url(sha, true);
    return $.getJSON(url, callback);
  }
};

window.Util = {
  dataFromDataURL: function(dataURL) {
    return dataURL.substr(dataURL.indexOf(',') + 1);
  },
  toCSON: function(obj) {
    var representation;
    representation = JSON.parse(JSON.stringify(obj));
    return Object.keys(representation).map(function(key) {
      var value;
      value = representation[key];
      return "" + key + ": " + (JSON.stringify(value));
    }).join("\n");
  }
};

window.Resource = {
  url: function(sha, crossOrigin) {
    var n, url;
    if (crossOrigin == null) {
      crossOrigin = false;
    }
    n = Math.floor(parseInt(sha.substring(0, 1), 16) / 4);
    url = "http://a" + n + ".pixiecdn.com/" + sha;
    if (crossOrigin) {
      return "" + url + "?" + location.host;
    } else {
      return url;
    }
  },
  imageFor: function(sha) {
    return $("<img>", {
      src: this.url(sha)
    }).get(0);
  }
};

["x", "y", "z"].each(function(dim, i) {
  return Object.defineProperty(Array.prototype, dim, {
    get: function() {
      return this[i];
    },
    set: function(x) {
      return this[i] = x;
    }
  });
});
